<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ChitChat</title>
    <script src="https://kit.fontawesome.com/8a0b394f55.js" crossorigin="anonymous" async defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Akatab:wght@400;500;600;700;800;900&display=swap');
      
      :root{
        --text-color: #eee;
        --main-font:  "Akatab";
      }

      body {
        background-color: #111;
        background-image: linear-gradient(to bottom right, #101010, #1f1f1f);
        color: var(--text-color);
        font-family: var(--main-font);
        border: none;
        margin: 0;

        main{
          opacity: 0;
          transition: all 0.5s linear;

          & > *{
            width: 100%;
            box-sizing: border-box;
          }
          #micSection{
            border-bottom: solid 3px #000;
            background-color: #222;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;

            #selectionEl{
              outline: none;
              border: solid 2px #050505;
              background-color: #1a1a1a;
              cursor: pointer;
              border-radius: 6px;
              color: #999;
              font-size: 13px;
              width: 300px;
              text-overflow: ellipsis;
              font-family: var(--main-font);
              white-space: nowrap;
            }
          }

          #avatarHolder{ 
            width: 100%;
            display: flex;
            flex-direction: row;

            #profilePicHolder{
              display: flex;
              flex-direction: column;
              justify-content: center;
              padding: 12px 20px;

              #profilePic{
                width: 110px;
                height: 110px;
                border-radius: 15px;

                #picChangeMenubutton{
                  border: black solid 3px;
                  width: 100%;
                  height: 100%;
                  border-radius: 15px;
                  opacity: 0;
                  top: 0px;
                  left: 0px;

                  &:hover{
                    opacity: 0.9;
                  }
                }
              }
            }

            #otherPeoplePicContainer{
              border-left: solid #000 3px;
              background-color: #111;
              display: flex;
              flex-grow: 1;
              flex-direction: row;
              flex-wrap: nowrap;
              overflow-x: auto;
              column-gap: 20px;
              padding: 0px 20px;

              &::-webkit-scrollbar {
                height: 8px;
              }

              &::-webkit-scrollbar-track {
                background: #0E0E0E;
              }

              &::-webkit-scrollbar-thumb {
                background: #222;
              }

              &::-webkit-scrollbar-thumb:hover {
                background: #333;
              }

              & > div{
                padding: 15px 0px;
                flex-shrink: 0;
              }
            }
          }

          #midSection{
            border-top: solid 3px #000;
            border-bottom: solid 3px #000;
            height: calc(100vh - 282px);
          }

          #footerSettings{
            background-color: #111;
            height: 75px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-evenly;
            padding-bottom: 5px;

            button{
              padding: 2px;
              border-radius: 10px;
              height: 34px;
              min-width: 34px;

              & > *{
                height: 26px;
              }
            }

            .selectedListenToYourself{
              background-color: #080;
            }

            .selectedMuteYourself{
              background-color: #B00;
            }
          }
        }

        button, #profilePicUploaderLabel {
          cursor: pointer;
          color: var(--text-color);
          border: black solid 2px;
          background-color: #333;
          transition: all 0.3s linear;
          outline: none;

          &:hover, &:focus{
            background-color: #444;
          }
        }
      }
    </style>
  </head>
  <body>
    <main id="main">
      <section id="micSection">
        <select id="selectionEl" name="selectedMic" title="Select a microphone" onchange="setLocalStream()"></select>
      </section>
      <section id="avatarHolder">
        <section id="ownPicContainer">%avatarContainer%</section>
        <section id="otherPeoplePicContainer"></section>
      </section>
      <section id="midSection"></section>
      <section id="footerSettings">
        <button title="Mute yourself (shorcut: 'M')" id="muteYourself" type="button" onclick="toggleMuteYourself()">
          <i class="fa-solid fa-microphone-slash"></i>
        </button>
        <button title="listen to yourself (shorcut: 'L')" id="listenToYourself" type="button" onclick="toggleListenToYourself()">
          <i class="fa-solid fa-ear-listen"></i>
        </button>
        <button title="exit" id="exitButton" type="button" onclick="exitRoom()">
          <i class="fa-solid fa-door-open"></i>
        </button>
      </section>
      <audio id="selfAudio" style="position: fixed; top: 0;left: 0;" autoplay muted></audio>
    </main>

    <div id="originalTemplateContainer" style="display: none;">
      <div>
        <div class="otherPeoplePic" style="border: 3px solid #000; background-color: #222; border-radius: 15px;overflow: hidden;width: 100px;height: 100px;">
          <canvas style="width: 100%;height: 100%;display: block"></canvas>
        </div>    
        <audio style="position: fixed; top: 0;left: 0;" autoplay></audio>
        <p style="margin: 0px;text-align: center;font-size: 14px;text-overflow: ellipsis;width: 100px;text-wrap: nowrap;overflow: hidden;line-height: 25px;border: transparent solid 3px;"></p>
      </div>
    </div>
  </body>
  <script>
    const g_checkUserStates = {
      SUCCESS: "SUCCESS",
      SESSION_TOKEN_MISSING: "SESSION_TOKEN_MISSING",
      USER_NOT_IN_SESSION_STORAGE: "USER_NOT_IN_SESSION_STORAGE",
      SESSION_TOKEN_USERNAME_MISMATCH: "SESSION_TOKEN_USERNAME_MISMATCH",
    }
    const g_generalStates = {
      TOO_MUCH_DATA: "TOO_MUCH_DATA",
      COOKIE_ISSUE: "COOKIE_ISSUE",
      NOT_POST: "NOT_POST",
      SERVER_ERROR: "SERVER_ERROR"
    }
    const g_wsServerToClientStates = {
      PING: "PING",
      USER_UPDATED_IMG: "USER_UPDATED_IMG",
      IMG_UPDATED_SUCCESSFULLY: "IMG_UPDATED_SUCCESSFULLY",
      NEW_CONNECTION_SUCCESSFUL: "NEW_CONNECTION_SUCCESSFUL",
      USER_DIED: "USER_DIED",
      OFFER_FROM_SOMEONE: "OFFER_FROM_SOMEONE",
      ANSWER_FROM_SOMEONE: "ANSWER_FROM_SOMEONE",
      PASSING_CANDIDATE: "PASSING_CANDIDATE",
      ERROR: "ERROR"
    };
    const g_wsClientToServerStates = {
      PONG: "PONG",
      NEW_CONNECTION: "NEW_CONNECTION",
      NEW_IMG: "NEW_IMG",
      PASS_OFFER: "PASS_OFFER",
      PASS_ANSWER: "PASS_ANSWER",
      PASS_CANDIDATE: "PASS_CANDIDATE",
      DO_STUFF: "DO_STUFF"
    };

    const template = document.querySelector("#originalTemplateContainer > div");
    const otherAvatarHolderEl = document.getElementById("otherPeoplePicContainer");
    const g_userStoreSet = new Set();
    const g_peerConnections = {};
    var g_localStream;
    var g_exitingRoom = false;

    window.onload = () => {
      fetch("/checkUser", { 
        method:"POST",
        body: localStorage.getItem("username"),
        signal: AbortSignal.timeout(5000)
      })
      .then(res => res.json())
      .then(res => {
        switch(res.status){
          case g_checkUserStates.SUCCESS: 
            startSocket(); 
            break;
          case g_generalStates.SERVER_ERROR:
            exitRoom("Server error. Please report this!", true);
            break;
          case g_generalStates.COOKIE_ISSUE:
            exitRoom("Cookie Issue!\nPlease report this!", true);
            break;
          case g_generalStates.NOT_POST:
          case g_checkUserStates.SESSION_TOKEN_MISSING:
          case g_checkUserStates.USER_NOT_IN_SESSION_STORAGE: 
          case g_checkUserStates.SESSION_TOKEN_USERNAME_MISMATCH: 
            exitRoom(`Encountered error: ${res.status}.`, true); 
            break;
          default:
            exitRoom("Default case reached!\nPlease report this!", true);
        }
      })
      .catch(err => exitRoom(`Error when fetching checkUser, please report this!\n${err}`, true));

      document.addEventListener('keydown', (event) => {
        if (event.key === 'M' || event.key === 'm') toggleMuteYourself();
        else if (event.key === 'L' || event.key === 'l') toggleListenToYourself();
      });
    }

    function startSocket(){
      const username = localStorage.getItem("username");
      try{
        /*G_SOCKET*/ //G_SOCKET will be replaced by a line which initializes websocket.
        g_socket.addEventListener('open', event => {
          g_socket.send(JSON.stringify({status: g_wsClientToServerStates.NEW_CONNECTION, username: username}));
        });
        g_socket.addEventListener("close", () => {
          if (!g_exitingRoom) {
            alert("Websocket closed! If this was not intended,\nthen please report it!");
            exitRoom();
          }
         });
        wsMessageStuff();
      }
      catch(err){
        alert("Websocket issue, try again later.");
        console.error(err);
      }
    }

    function wsMessageStuff(){
      g_socket.addEventListener('message', event => {
        let jsonData;
        try { jsonData = JSON.parse(event.data); }
        catch(err){
          exitRoom("Response cannot be json'ed\nPlease report this!", true);
          return;
        }

        try{          
          const states = g_wsServerToClientStates;
          switch (jsonData.status) {
            case states.PING:                       sendPONG(); break;
            case states.NEW_CONNECTION_SUCCESSFUL:  showMain(); break;
            case states.IMG_UPDATED_SUCCESSFULLY:   console.log("Image successfully updated in the backend."); break;
            case states.USER_UPDATED_IMG:           setOtherUsersDiv(JSON.parse(jsonData.data)); break; // Also for new users
            case states.USER_DIED:                  deleteUserDiv(jsonData.username); break;
            case states.OFFER_FROM_SOMEONE:         gotOfferFromSomeone(jsonData.fromUser, jsonData.offer); break;
            case states.ANSWER_FROM_SOMEONE:        gotAnswerFromSomeone(jsonData.fromUser, jsonData.answer); break;
            case states.PASSING_CANDIDATE:          gotCandidateUpdate(jsonData.fromUser, jsonData.candidate); break;
            case states.ERROR:                      displayErrorMsg(jsonData); break;
            default: throw new Error("Unknown status reached!");
          }
        }
        catch(err) {
          console.error(err);
          alert(`Error processing server response with status: "${jsonData.status}".\nPlease report this!`);
          exitRoom();
        }
      });
    }

    function sendPONG() {
      g_socket.send(
        JSON.stringify({
          status: g_wsClientToServerStates.PONG, 
          username: localStorage.getItem("username")
        })
      );
    }

    async function showMain(){
      await setMicSelection();
      navigator.mediaDevices.addEventListener('devicechange', setMicSelection);
      if (window.innerWidth <= window.innerHeight) {
        const footerEl = document.getElementById("footerSettings");
        footerEl.style.height = "150px";
        footerEl.style.paddingBottom = "80px";
      }
      const mainEl = document.getElementById("main");
      mainEl.style.opacity = "1";
      setAllUsersDiv();
    }

    async function setMicSelection(){
      const selectionEl = document.getElementById("selectionEl");
      selectionEl.innerHTML = "";
      await navigator.mediaDevices.getUserMedia({audio: true}); 
      const devices = await navigator.mediaDevices.enumerateDevices();
      let audioDevices = 0;
      for (let device of devices) { 
        if (device.kind === "audioinput" && device.deviceId.length) {
          let optionEl = document.createElement("option");
          optionEl.innerText = device.label;
          optionEl.value = device.deviceId;
          selectionEl.appendChild(optionEl);
          audioDevices += 1;
        }
      }
      if (!audioDevices) exitRoom("No audio input found!");
      await setLocalStream();
    }

    async function setLocalStream() {
      if (g_localStream) g_localStream.getAudioTracks()[0].stop();
      g_localStream = await navigator.mediaDevices.getUserMedia({audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        deviceId: {exact: document.getElementById("selectionEl").value}
      }});
      const audioElement = document.getElementById('selfAudio');
      audioElement.srcObject = g_localStream;
      const audioTrack = g_localStream.getAudioTracks()[0];
      Object.keys(g_peerConnections).forEach(username => {
        let sender = g_peerConnections[username].getSenders().find(s => s.track.kind == "audio");
        if (sender) sender.replaceTrack(audioTrack);
        else g_peerConnections[username].addTrack(audioTrack, g_localStream);
      });
      if (document.getElementById('muteYourself').classList.contains("selectedMuteYourself")) audioTrack.enabled = false;
    }

    function setAllUsersDiv() {
      //set curUser first
      let curUser = localStorage.getItem("username");
      const editableNameEl = document.getElementById("editableName");
      editableNameEl.value = curUser;
      editableNameEl.readOnly = true;
      
      //for other users
      fetch("/getAllUsersPic", { signal: AbortSignal.timeout(5000) })
      .then(res => res.json())
      .then(res => {
        for (let user in res) {
          if (user === curUser) continue;
          setOtherUsersDiv({username: user, imgData: res[user]});
        }
        sendOfferToEveryone();
      })
      .catch(err => exitRoom(`Error when fetching user pics, please report this!\n${err}`, true));
    }

    function setOtherUsersDiv(inputData){
      const {username, imgData} = inputData;
      const alreadyExists = g_userStoreSet.has(username);
      if (alreadyExists) {
        const userDiv = document.getElementById(`divFor${username}`);
        const curCnv = userDiv.firstElementChild.firstElementChild;
        const curCtx = curCnv.getContext("2d");
        const image = new Image();
        image.onload = () => {
          if (image.width < image.height) curCnv.width = curCnv.height = image.width;
          else curCnv.width = curCnv.height = image.height;
          curCtx.reset();
          curCtx.drawImage(image, 0, 0);
        }
        image.src = imgData;
      }
      else {
        const elToAdd = template.cloneNode(true);
        elToAdd.title = username;
        elToAdd.id = `divFor${username}`;
        const curCnv = elToAdd.firstElementChild.firstElementChild;
        const curCtx = curCnv.getContext("2d");
        const image = new Image();
        image.onload = () => {
          if (image.width < image.height) curCnv.width = curCnv.height = image.width;
          else curCnv.width = curCnv.height = image.height;
          curCtx.reset();
          curCtx.drawImage(image, 0, 0);
          otherAvatarHolderEl.appendChild(elToAdd);
        }
        image.src = imgData;
        g_userStoreSet.add(username);
        elToAdd.lastElementChild.innerText = username;
        elToAdd.querySelector("audio").id = `audioFor${username}`;
      }
    }

    function displayErrorMsg(jsonData){
      if ("msg" in jsonData) console.error("WebSocketServerError:", jsonData.msg);
      else console.error("Property msg not in jsonData:", jsonData);
    }

    function toggleMuteYourself(){
      const buttonElement = document.getElementById('muteYourself');
      if (buttonElement.classList.contains("selectedMuteYourself")) { 
        buttonElement.classList.remove("selectedMuteYourself");
        if (g_localStream) g_localStream.getAudioTracks()[0].enabled = true;
      }
      else {
        buttonElement.classList.add("selectedMuteYourself");
        if (g_localStream) g_localStream.getAudioTracks()[0].enabled = false;
      }
    }

    function toggleListenToYourself(){
      const audioElement = document.getElementById('selfAudio');
      const buttonElement = document.getElementById('listenToYourself');
      if (audioElement.muted) {  
        audioElement.muted = false;
        buttonElement.classList.add("selectedListenToYourself");
      }
      else {
        audioElement.muted = true;
        buttonElement.classList.remove("selectedListenToYourself");
      }
    }

    function exitRoom(errMsg = null, doAlert = false){ 
      g_exitingRoom = true;
      if (errMsg){
        console.error(errMsg);
        if (doAlert) alert(errMsg);
      }
      window.location.href = "/"; 
    }

    function sendOfferToEveryone(){
      //https://webrtc.org/getting-started
      g_userStoreSet.forEach(username => {
        g_peerConnections[username] = new RTCPeerConnection({'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]});
        g_peerConnections[username].addTrack(g_localStream.getAudioTracks()[0], g_localStream);
        addOnTrackEvent(username);
        addOnIceCandidateEvent(username);
        sendOffer(username);
      });
    }

    async function sendOffer(toUser){
      const offer = await g_peerConnections[toUser].createOffer();
      await g_peerConnections[toUser].setLocalDescription(offer);
      g_socket.send(
        JSON.stringify({
          status: g_wsClientToServerStates.PASS_OFFER, 
          username: localStorage.getItem("username"),
          toUser: toUser,
          offer: offer
        })
      );
    }

    async function gotOfferFromSomeone(offerer, offerAsString){
      console.log(`Got RTC offer from ${offerer}`);
      g_peerConnections[offerer] = new RTCPeerConnection({'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]});
      g_localStream.getTracks().forEach(track => g_peerConnections[offerer].addTrack(track, g_localStream));
      addOnTrackEvent(offerer);
      addOnIceCandidateEvent(offerer);
      g_peerConnections[offerer].setRemoteDescription(new RTCSessionDescription(JSON.parse(offerAsString)));
      const answer = await g_peerConnections[offerer].createAnswer();
      await g_peerConnections[offerer].setLocalDescription(answer);
      g_socket.send(
        JSON.stringify({
          status: g_wsClientToServerStates.PASS_ANSWER,
          username: localStorage.getItem("username"),
          toUser: offerer,
          answer: answer
        })
      );
    }

    async function gotAnswerFromSomeone(fromUser, answerAsString){
      console.log(`Got RTC answer from ${fromUser}`);
      const remoteDesc = new RTCSessionDescription(JSON.parse(answerAsString));
      await g_peerConnections[fromUser].setRemoteDescription(remoteDesc);
    }

    function gotCandidateUpdate(fromUser, candidateAsString){
      if (g_peerConnections[fromUser])
        g_peerConnections[fromUser].addIceCandidate(JSON.parse(candidateAsString));
    }

    function addOnTrackEvent(username) {
      g_peerConnections[username].addEventListener('track', async (event) => {
        const [remoteStream] = event.streams;
        document.querySelector(`#divFor${username} audio`).srcObject = remoteStream;
      });
    }

    function addOnIceCandidateEvent(username) {      
      g_peerConnections[username].onicecandidate = (event) => {
        if(event.candidate)
          g_socket.send(
            JSON.stringify({
              status: g_wsClientToServerStates.PASS_CANDIDATE,
              username: localStorage.getItem("username"),
              toUser: username,
              candidate: event.candidate
            })
          );
      }
    }
    
    function deleteUserDiv(username){
      const elToRemove = document.getElementById(`divFor${username}`);
      if (elToRemove) {
        elToRemove.remove();
        g_userStoreSet.delete(username);
      }
      else { console.error(`Tried to delete user ${username}`); }
    }

    window.onpagehide = () => {
      navigator.sendBeacon("/deleteUser", localStorage.getItem("username"));
      g_socket.close();
    };

    function makeServerDoStuff(command) {
      g_socket.send(JSON.stringify({
        status: g_wsClientToServerStates.DO_STUFF,
        username: localStorage.getItem("username"),
        command: command
      }));
    }
  </script>
</html>
